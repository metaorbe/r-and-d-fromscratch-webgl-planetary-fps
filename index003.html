<!DOCTYPE html>
<html>
<head>
    <title>Lunar WebGL Maquette FPS</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
        #instructions {
            position: absolute; top: 10px; left: 10px; color: white; font-family: Arial;
            background: rgba(0, 0, 0, 0.7); padding: 10px;
        }
    </style>
</head>
<body>
    <div id="instructions">Click to start FPS controls<br>ZQSD: Move, Mouse Wheel: Zoom</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 1700000); // near 0.05m, far 1700km
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Center Marker (Red Sphere) ---
        const centerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32), // 1m radius
            new THREE.MeshPhongMaterial({ color: 0xff0000, flatShading: true })
        );
        centerSphere.position.set(0, 0, 0);
        scene.add(centerSphere);
        console.log('Added center sphere at [0, 0, 0], radius: 1m');

        // --- Axes Helper ---
        const axesHelper = new THREE.AxesHelper(1700000); // 1700km = 1700000m
        scene.add(axesHelper);
        console.log('Added axes helper at [0, 0, 0], size: 1700000m (1700km)');

        // --- Test Cube (Yellow) ---
        const cubeGeometry = new THREE.BoxGeometry(10000, 10000, 10000); // 10km = 10000m
        const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, flatShading: true });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 0, 0);
        scene.add(cube);
        console.log('Added test cube at [0, 0, 0], size: 10000m (10km)');

        // --- Matrix (NormMatrix, PopMatrix) ---
        let normMatrix = null;
        let normMatrixRadius = 0; // To be determined from bounding box
        let popVectors = [];

        // Load NormMatrix
        const loader = new THREE.GLTFLoader();
        loader.load('NormMatrix.gltf', (gltf) => {
            normMatrix = gltf.scene;
            normMatrix.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshPhongMaterial({
                        color: 0xff00ff, // Pink
                        side: THREE.FrontSide,
                        flatShading: true
                    });
                    if (child.geometry && !child.geometry.attributes.normal) {
                        child.geometry.computeVertexNormals();
                        console.log('Computed normals for NormMatrix');
                    }
                    console.log('NormMatrix geometry:', child.geometry.attributes);
                    console.log('NormMatrix scale:', child.scale);
                    console.log('NormMatrix position:', child.position);
                }
            });
            normMatrix.position.set(0, 0, 0);
            scene.add(normMatrix);
            console.log('Loaded NormMatrix.gltf');
            const boxNorm = new THREE.Box3().setFromObject(normMatrix);
            normMatrixRadius = Math.max(
                Math.abs(boxNorm.max.x), Math.abs(boxNorm.min.x),
                Math.abs(boxNorm.max.y), Math.abs(boxNorm.min.y),
                Math.abs(boxNorm.max.z), Math.abs(boxNorm.min.z)
            );
            console.log('NormMatrix bounding box (m):', boxNorm.min, boxNorm.max);
            console.log('NormMatrix radius (m):', normMatrixRadius);
        }, undefined, (error) => {
            console.error('Error loading NormMatrix.gltf:', error);
        });

        // Load PopMatrix
        loader.load('PopMatrix.gltf', (gltf) => {
            const popMatrix = gltf.scene;
            popMatrix.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const positions = child.geometry.attributes.position.array;
                    const indices = child.geometry.index ? child.geometry.index.array : null;
                    if (indices) {
                        for (let i = 0; i < indices.length; i += 3) {
                            const a = indices[i] * 3, b = indices[i + 1] * 3, c = indices[i + 2] * 3;
                            const v1 = new THREE.Vector3(positions[a], positions[a + 1], positions[a + 2]);
                            const v2 = new THREE.Vector3(positions[b], positions[b + 1], positions[b + 2]);
                            const v3 = new THREE.Vector3(positions[c], positions[c + 1], positions[c + 2]);
                            const center = new THREE.Vector3().addVectors(v1, v2).add(v3).divideScalar(3);
                            popVectors.push(center); // No resizing
                        }
                        console.log('PopMatrix vectors count:', popVectors.length);
                        console.log('Sample popVectors distances (m):', popVectors.slice(0, 5).map(v => v.length()));
                    } else {
                        console.warn('No indices found in PopMatrix geometry');
                    }
                }
            });

            // Create Cyan Sphere Marker
            const marker = new THREE.Mesh(
                new THREE.SphereGeometry(500, 16, 16), // 0.5km = 500m
                new THREE.MeshPhongMaterial({ color: 0x00ffff, flatShading: true })
            );
            if (popVectors.length > 1425) {
                marker.position.copy(popVectors[1425]);
                console.log('Added marker at popVectors[1425]:', popVectors[1425], 'Distance:', popVectors[1425].length(), 'm');
            } else {
                console.warn('No valid popVectors[1425], using default position');
                marker.position.set(0, 0, 1000); // Fallback 1000m
                console.log('Added marker at default position:', marker.position, 'Distance:', marker.position.length(), 'm');
            }
            scene.add(marker);

            // Set initial player position
            if (popVectors.length > 1425) {
                player.position.copy(popVectors[1425]);
                console.log('Player position set to popVectors[1425]:', player.position, 'm');
            } else {
                console.warn('No valid popVectors[1425], using default player position');
                player.position.set(0, 0, 1000); // Fallback 1000m
            }
            console.log('Player distance from center (m):', player.position.length());
            camera.lookAt(0, 0, 0);
        }, undefined, (error) => {
            console.error('Error loading PopMatrix.gltf:', error);
        });

        // --- Player (Camera for FPS) ---
        const player = camera;

        // --- PointerLockControls ---
        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('click', () => controls.lock());
        document.getElementById('instructions').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => {
            document.getElementById('instructions').style.display = 'none';
            console.log('Controls locked');
        });
        controls.addEventListener('unlock', () => {
            document.getElementById('instructions').style.display = 'block';
            console.log('Controls unlocked');
        });

        // --- Keyboard Controls (AZERTY) ---
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        console.log('Keyboard controls set up');

        // --- Zoom Control ---
        document.addEventListener('wheel', (event) => {
            camera.fov = Math.max(10, Math.min(100, camera.fov + event.deltaY * 0.1));
            camera.updateProjectionMatrix();
            console.log('Camera fov:', camera.fov);
        });

        // --- Physics ---
        const gravity = 1000; // 1km/s² = 1000m/s²
        let velocity = new THREE.Vector3(0, 0, 0);
        const dt = 1 / 60; // 60fps
        const moveSpeed = 30000; // 30km/s = 30000m/s

        // --- NormMatrix Collision ---
        function checkNormMatrixCollision() {
            if (!normMatrix) return false;
            const playerDistance = player.position.length();
            if (playerDistance < normMatrixRadius) {
                player.position.setLength(normMatrixRadius); // Stop at surface
                velocity.set(0, 0, 0); // Reset velocity
                console.log('Collided with NormMatrix at distance:', playerDistance, 'm');
                return true;
            }
            return false;
        }

        // --- Lighting ---
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Strong
        directionalLight.position.set(10000000, 10000000, 10000000); // 10000km
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.2)); // Light ambient

        // --- Animation Loop ---
        let lastLog = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            // Apply gravity
            if (!checkNormMatrixCollision()) {
                const gravityDir = player.position.clone().normalize().negate(); // Toward center
                velocity.addScaledVector(gravityDir, gravity * dt);
            }

            // Move player
            const direction = new THREE.Vector3();
            controls.getDirection(direction);
            const right = new THREE.Vector3().crossVectors(direction, controls.getObject().up).normalize();
            if (moveForward) velocity.addScaledVector(direction, moveSpeed * dt);
            if (moveBackward) velocity.addScaledVector(direction, -moveSpeed * dt);
            if (moveLeft) velocity.addScaledVector(right, -moveSpeed * dt);
            if (moveRight) velocity.addScaledVector(right, moveSpeed * dt);
            player.position.addScaledVector(velocity, dt);

            // Log position
            if (time - lastLog > 1000) {
                console.log('Player position (m):', player.position);
                console.log('Player distance from center (m):', player.position.length());
                lastLog = time;
            }

            renderer.render(scene, camera);
        }
        animate(0);

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
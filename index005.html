<!DOCTYPE html>
<html>
<head>
    <title>Lunar WebGL Maquette FPS</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
        #instructions {
            position: absolute; top: 10px; left: 10px; color: white; font-family: Arial;
            background: rgba(0, 0, 0, 0.7); padding: 10px;
        }
    </style>
</head>
<body>
    <div id="instructions">Click to start FPS controls<br>WASD: Move, Mouse Wheel: Zoom</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.20, 500000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Center Marker (Red Sphere) ---
        const centerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32),
            new THREE.MeshPhongMaterial({ color: 0xff0000, flatShading: true })
        );
        centerSphere.position.set(0, 0, 0);
        scene.add(centerSphere);

        // --- Axes Helper ---
        const axesHelper = new THREE.AxesHelper(1700000);
        scene.add(axesHelper);

        // --- Test Cube (Yellow) ---
        const cubeGeometry = new THREE.BoxGeometry(10000, 10000, 10000);
        const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, flatShading: true });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 0, 0);
        scene.add(cube);

        // --- Matrix (NormMatrix, PopMatrix, LimitMatrix, PlayerEntity) ---
        let normMatrix = null;
        let normMatrixRadius = 0;
        let popVectors = [];
        let limitMatrix = null;
        let limitMatrixRadius = 0;
        let playerEntity = null;
        let playerView = null;

        // Load NormMatrix
        const loader = new THREE.GLTFLoader();
        loader.load('NormMatrix.gltf', (gltf) => {
            normMatrix = gltf.scene;
            normMatrix.traverse((child) => {
                if (child.isMesh) {
                    if (!child.material) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    }
                    if (child.geometry && !child.geometry.attributes.normal) {
                        child.geometry.computeVertexNormals();
                    }
                }
            });
            normMatrix.position.set(0, 0, 0);
            scene.add(normMatrix);
            const boxNorm = new THREE.Box3().setFromObject(normMatrix);
            normMatrixRadius = Math.max(
                Math.abs(boxNorm.max.x), Math.abs(boxNorm.min.x),
                Math.abs(boxNorm.max.y), Math.abs(boxNorm.min.y),
                Math.abs(boxNorm.max.z), Math.abs(boxNorm.min.z)
            );
        }, undefined, (error) => {
            console.error('Error loading NormMatrix.gltf:', error);
        });

        // Load PopMatrix
        loader.load('PopMatrix.gltf', (gltf) => {
            const popMatrix = gltf.scene;
            popMatrix.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const positions = child.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        popVectors.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
                    }
                    if (!child.material) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    }
                    if (child.geometry && !child.geometry.attributes.normal) {
                        child.geometry.computeVertexNormals();
                    }
                }
            });
            popMatrix.position.set(0, 0, 0);
            scene.add(popMatrix);

            // Create Cyan Sphere Marker
            const marker = new THREE.Mesh(
                new THREE.SphereGeometry(500, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            if (popVectors.length > 525) {
                marker.position.copy(popVectors[525]);
            } else {
                marker.position.set(0, 0, 1000);
            }
            scene.add(marker);

            // Set initial player position
            if (popVectors.length > 525 && playerEntity) {
                playerEntity.position.copy(popVectors[525]);
            } else if (popVectors.length > 525) {
                camera.position.copy(popVectors[525]).add(new THREE.Vector3(0, 2, 0));
                camera.rotation.set(Math.PI / 2, 0, 0);
            } else {
                camera.position.set(0, 2, 1000);
                playerEntity && playerEntity.position.set(0, 0, 1000);
                camera.rotation.set(Math.PI / 2, 0, 0);
            }
        }, undefined, (error) => {
            console.error('Error loading PopMatrix.gltf:', error);
        });

        // Load LimitMatrix
        loader.load('LimitMatrix.gltf', (gltf) => {
            limitMatrix = gltf.scene;
            limitMatrix.traverse((child) => {
                if (child.isMesh) {
                    if (!child.material) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    }
                    if (child.geometry && !child.geometry.attributes.normal) {
                        child.geometry.computeVertexNormals();
                    }
                }
            });
            limitMatrix.position.set(0, 0, 0);
            scene.add(limitMatrix);
            const boxLimit = new THREE.Box3().setFromObject(limitMatrix);
            limitMatrixRadius = Math.max(
                Math.abs(boxLimit.max.x), Math.abs(boxLimit.min.x),
                Math.abs(boxLimit.max.y), Math.abs(boxLimit.min.y),
                Math.abs(boxLimit.max.z), Math.abs(boxLimit.min.z)
            );
        }, undefined, (error) => {
            console.error('Error loading LimitMatrix.gltf:', error);
        });

        // Load PlayerEntity and PlayerView
        loader.load('Player.gltf', (gltf) => {
            playerEntity = gltf.scene;
            playerEntity.matrixAutoUpdate = true;
            playerEntity.rotation.order = 'YXZ';
            playerEntity.traverse((child) => {
                if (child.isMesh) {
                    if (!child.material) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                    }
                    if (child.geometry && !child.geometry.attributes.normal) {
                        child.geometry.computeVertexNormals();
                    }
                }
                if (child.isCamera) {
                    console.log('Found camera in Player.gltf, name:', child.name, 'position:', child.position);
                    if (child.name === 'PlayerView') {
                        playerView = child;
                    }
                }
            });
            playerEntity.position.set(0, 0, 0);
            playerEntity.rotation.set(0, 0, 0);
            playerEntity.scale.set(1, 1, 1);
            scene.add(playerEntity);
            if (popVectors.length > 525) {
                playerEntity.position.copy(popVectors[525]);
            }
            if (playerView) {
                console.log('PlayerView detected, position:', playerView.position, 'rotation:', playerView.rotation.toVector3());
                camera.position.copy(playerEntity.position).add(new THREE.Vector3(0, 2, 0));
                camera.rotation.set(Math.PI / 2, 0, 0);
            } else {
                console.warn('No PlayerView camera found, using fallback position');
                camera.position.copy(playerEntity.position).add(new THREE.Vector3(0, 2, 0));
                camera.rotation.set(Math.PI / 2, 0, 0);
            }
        }, undefined, (error) => {
            console.error('Error loading Player.gltf:', error);
        });

        // --- Player (Camera for FPS) ---
        const player = playerEntity || camera;

        // --- PointerLockControls ---
        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('click', () => controls.lock());
        document.getElementById('instructions').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => {
            document.getElementById('instructions').style.display = 'none';
        });
        controls.addEventListener('unlock', () => {
            document.getElementById('instructions').style.display = 'block';
        });

        // --- Keyboard Controls (QWERTY) ---
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // --- Zoom Control ---
        document.addEventListener('wheel', (event) => {
            camera.fov = Math.max(10, Math.min(100, camera.fov + event.deltaY * 0.1));
            camera.updateProjectionMatrix();
        });

        // --- Physics ---
        const gravity = 1000;
        let velocity = new THREE.Vector3(0, 0, 0);
        const dt = 1 / 60;
        const moveSpeed = 10000;

        // --- Collision (NormMatrix and LimitMatrix) ---
        function checkMatrixCollision() {
            let collided = false;
            const position = playerEntity ? playerEntity.position : camera.position;
            if (normMatrix && position.length() <= normMatrixRadius) {
                position.setLength(normMatrixRadius + 3);
                velocity.set(0, 0, 0);
                console.log('Collided with NormMatrix at distance:', position.length());
                collided = true;
            }
            if (limitMatrix && position.length() >= limitMatrixRadius) {
                position.setLength(limitMatrixRadius - 1000000);
                velocity.set(0, 0, 0);
                console.log('Collided with LimitMatrix at distance:', position.length());
                collided = true;
            }
            return collided;
        }

        // --- Lighting ---
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(10000000, 10000000, 10000000);
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.2));

        // --- Animation Loop ---
        let lastLog = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            // Apply gravity
            if (!checkMatrixCollision()) {
                const position = playerEntity ? playerEntity.position : camera.position;
                const gravityDir = position.clone().normalize().negate();
                velocity.addScaledVector(gravityDir, gravity * dt);
            }

            // Move player
            const direction = new THREE.Vector3();
            controls.getDirection(direction);
            const right = new THREE.Vector3().crossVectors(direction, controls.getObject().up).normalize();
            if (moveForward) velocity.addScaledVector(direction, moveSpeed * dt);
            if (moveBackward) velocity.addScaledVector(direction, -moveSpeed * dt);
            if (moveLeft) velocity.addScaledVector(right, -moveSpeed * dt);
            if (moveRight) velocity.addScaledVector(right, moveSpeed * dt);
            const position = playerEntity ? playerEntity.position : camera.position;
            position.addScaledVector(velocity, dt);

            // Sync PlayerEntity rotation with camera (yaw only)
            if (playerEntity) {
                playerEntity.quaternion.copy(controls.getObject().quaternion);
                playerEntity.rotation.x = 0;
                playerEntity.rotation.z = 0;
            }

            // Update camera to follow PlayerEntity
            if (playerEntity) {
                camera.position.copy(playerEntity.position).add(new THREE.Vector3(0, 2, 0));
                camera.rotation.copy(controls.getObject().rotation);
            }

            // Log critical info every 1s
            if (time - lastLog > 1000 && playerEntity) {
                console.log('Player position (m):', position);
                console.log('Camera position (m):', camera.position);
                console.log('Camera rotation:', camera.rotation.toVector3());
                console.log('PlayerEntity rotation:', playerEntity.rotation.toVector3());
                lastLog = time;
            }

            renderer.render(scene, camera);
        }
        animate(0);

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
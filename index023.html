<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Lunar WebGL Maquette FPS — Étape A (clean)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { width: 100%; height: 100%; display: block; }
    #instructions {
      position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, system-ui, sans-serif;
      background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; line-height: 1.35;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="instructions">
    Click to start FPS controls<br/>
    WASD: Move, Space: Down, Shift: Up, Q: Stabilize, Mouse Wheel: Zoom
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
  // ---------- Scene & Renderer ----------
  const scene = new THREE.Scene();
  const playerView = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.5, 4000000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ---------- Helpers (center + axes) ----------
  const centerSphere = new THREE.Mesh(
    new THREE.SphereGeometry(1, 16, 16),
    new THREE.MeshPhongMaterial({ color: 0xff0000, flatShading: true })
  );
  centerSphere.position.set(0, 0, 0);
  scene.add(centerSphere);

  const axesHelper = new THREE.AxesHelper(1700000);
  scene.add(axesHelper);

  // ---------- Test cube ----------
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(10000, 10000, 10000),
    new THREE.MeshPhongMaterial({ color: 0xffff00, flatShading: true })
  );
  scene.add(cube);

  // ---------- Globals ----------
  let normMatrix = null;
  let normMatrixRadius = 0;
  let popVectors = [];
  let limitMatrix = null;
  let limitMatrixRadius = 0;
  let playerEntity = null;

  const raycaster = new THREE.Raycaster();

  // ---------- Loaders ----------
  const loader = new THREE.GLTFLoader();

  function computeBoundingRadiusFromObject(root) {
    const box = new THREE.Box3().setFromObject(root);
    return Math.max(
      Math.abs(box.max.x), Math.abs(box.min.x),
      Math.abs(box.max.y), Math.abs(box.min.y),
      Math.abs(box.max.z), Math.abs(box.min.z)
    );
  }

  async function loadAllAssets() {
    await Promise.all([
      new Promise((resolve) => {
        loader.load('NormMatrix.gltf', (gltf) => {
          normMatrix = gltf.scene;
          normMatrix.traverse((child) => {
            if (child.isMesh) {
              if (!child.material) {
                child.material = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
              } else {
                child.material.side = THREE.DoubleSide;
              }
              // IMPORTANT: ne pas recalculer -> on veut les normales Blender (smooth)
            }
          });
          normMatrix.position.set(0, 0, 0);
          scene.add(normMatrix);
          normMatrixRadius = computeBoundingRadiusFromObject(normMatrix);
          resolve();
        }, undefined, (err) => { console.error('Error loading NormMatrix.gltf:', err); resolve(); });
      }),

      new Promise((resolve) => {
        loader.load('PopMatrix.gltf', (gltf) => {
          const popMatrix = gltf.scene;
          popMatrix.traverse((child) => {
            if (child.isMesh && child.geometry) {
              const positions = child.geometry.attributes.position.array;
              for (let i = 0; i < positions.length; i += 3) {
                popVectors.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
              }
              if (!child.material) {
                child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
              }
              if (child.geometry && !child.geometry.attributes.normal) {
                child.geometry.computeVertexNormals();
              }
            }
          });
          popMatrix.position.set(0, 0, 0);
          scene.add(popMatrix);

          // Cyan marker at index 525 if exists
          const marker = new THREE.Mesh(
            new THREE.SphereGeometry(500, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0x00ffff })
          );
          if (popVectors.length > 525) {
            marker.position.copy(popVectors[525]);
          } else {
            marker.position.set(0, 0, 1000);
          }
          scene.add(marker);
          resolve();
        }, undefined, (err) => { console.error('Error loading PopMatrix.gltf:', err); resolve(); });
      }),

      new Promise((resolve) => {
        loader.load('LimitMatrix.gltf', (gltf) => {
          limitMatrix = gltf.scene;
          limitMatrix.traverse((child) => {
            if (child.isMesh) {
              if (!child.material) {
                child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
              }
              if (child.geometry && !child.geometry.attributes.normal) {
                child.geometry.computeVertexNormals();
              }
              if (child.geometry) {
                const positions = child.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                  const v = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]).applyMatrix4(child.matrixWorld);
                  limitMatrixRadius = Math.max(limitMatrixRadius, v.length());
                }
              }
            }
          });
          limitMatrix.position.set(0, 0, 0);
          scene.add(limitMatrix);
          resolve();
        }, undefined, (err) => { console.error('Error loading LimitMatrix.gltf:', err); resolve(); });
      }),

      new Promise((resolve) => {
        loader.load('Player.gltf', (gltf) => {
          playerEntity = gltf.scene;
          playerEntity.matrixAutoUpdate = true;
          playerEntity.rotation.order = 'YXZ';
          playerEntity.traverse((child) => {
            if (child.isMesh) {
              if (!child.material) {
                child.material = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });
              }
              if (child.geometry && !child.geometry.attributes.normal) {
                child.geometry.computeVertexNormals();
              }
            }
          });
          playerEntity.position.set(0, 0, 0);
          playerEntity.rotation.set(0, 0, 0);
          playerEntity.scale.set(1, 1, 1);
          scene.add(playerEntity);
          playerEntity.add(playerView);
          playerView.position.set(0, 2, 0);
          if (popVectors.length > 525) playerEntity.position.copy(popVectors[525]);
          playerEntity.add(pivotControls);
          resolve();
        }, undefined, (err) => { console.error('Error loading Player.gltf:', err); resolve(); });
      }),

      new Promise((resolve) => {
        loader.load('BlenderAxes.gltf', (gltf) => {
          const blenderAxes = gltf.scene;
          blenderAxes.position.set(0, 0, 0);
          scene.add(blenderAxes);
          resolve();
        }, undefined, (err) => { console.error('Error loading BlenderAxes.gltf:', err); resolve(); });
      })
    ]);

    // Camera placement fallback if Player not loaded
    if (popVectors.length > 525 && playerEntity) {
      playerEntity.position.copy(popVectors[525]);
      playerView.position.set(0, 2, 0);
    } else if (popVectors.length > 525) {
      playerView.position.copy(popVectors[525]).add(new THREE.Vector3(0, 2, 0));
    } else {
      playerView.position.set(0, 2, 1000);
      if (playerEntity) playerEntity.position.set(0, 0, 1000);
    }
  }

  // ---------- Controls ----------
  const pivotControls = new THREE.Object3D();
  scene.add(pivotControls);
  const controls = new THREE.PointerLockControls(pivotControls, renderer.domElement);

  const keyStates = { KeyW: false, KeyS: false, KeyA: false, KeyD: false, Space: false, ShiftLeft: false, KeyQ: false };
  document.addEventListener('click', () => controls.lock());
  document.getElementById('instructions').addEventListener('click', () => controls.lock());
  controls.addEventListener('lock', () => { document.getElementById('instructions').style.display = 'none'; });
  controls.addEventListener('unlock', () => { document.getElementById('instructions').style.display = 'block'; });

  // ---------- Key handling ----------
  document.addEventListener('keydown', (event) => {
    if (keyStates[event.code] === undefined || keyStates[event.code]) return;
    keyStates[event.code] = true;
  });
  document.addEventListener('keyup', (event) => {
    if (keyStates[event.code] === undefined) return;
    keyStates[event.code] = false;
  });

  // ---------- Zoom ----------
  document.addEventListener('wheel', (event) => {
    playerView.fov = Math.max(10, Math.min(100, playerView.fov + event.deltaY * 0.1));
    playerView.updateProjectionMatrix();
  }, { passive: true });

  // ---------- Mouse modes ----------

  let mouseMoved = false;
  document.addEventListener('mousemove', () => { if (controls.isLocked) mouseMoved = true; });

  // ---------- Physics ----------
  const gravity = 1000;
  let velocity = new THREE.Vector3(0, 0, 0);
  let stabilizationFactor = 0;
  let prevYaw = 0;

  // ---------- Collision ----------
  let lastCollisionLog = 0;
  function checkMatrixCollision(timeMs) {
    const entity = playerEntity ? playerEntity : playerView;
    const position = entity.position;
    let collided = false;

    if (normMatrix && popVectors.length > 525 && position.length() <= normMatrixRadius) {
      if (playerEntity) playerEntity.position.copy(popVectors[525]);
      velocity.set(0, 0, 0);
      collided = true;
      if (timeMs - lastCollisionLog > 5000) { lastCollisionLog = timeMs; }
    }

    if (limitMatrix && position.length() >= limitMatrixRadius) {
      position.setLength(limitMatrixRadius - 1000000);
      velocity.set(0, 0, 0);
      collided = true;
      if (timeMs - lastCollisionLog > 5000) { lastCollisionLog = timeMs; }
    }
    return collided;
  }

  // ---------- Lights ----------
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
  directionalLight.position.set(10000000, 10000000, 10000000);
  scene.add(directionalLight);
  scene.add(new THREE.AmbientLight(0x404040, 0.25));

  // ---------- Animation ----------
  let lastTime = performance.now();
  function animate(nowMs) {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, (nowMs - lastTime) / 1000); // clamp to avoid big jumps
    lastTime = nowMs;

    // Stabilization factor
    stabilizationFactor = keyStates.KeyQ ? Math.min(stabilizationFactor + dt, 1) : Math.max(stabilizationFactor - dt, 0);

    // Surface normal (toward center)
    const normal = (playerEntity ? playerEntity.position : playerView.position).clone().normalize();

    // Optional: raycast against NormMatrix root (robust to multi-mesh GLTF)
    if (playerEntity && normMatrix) {
      const toCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), playerEntity.position).normalize();
      raycaster.set(playerEntity.position, toCenter);
      // Intersect full root to cover multi-mesh
      const intersects = raycaster.intersectObject(normMatrix, true);
      if (intersects.length > 0) {
        const hit = intersects[0];
        // We could use hit.face.normal here if needed, but physics remains based on radial normal.
      }
    }

    // Gravity
    if (!checkMatrixCollision(nowMs)) {
      velocity.addScaledVector(normal.clone().negate(), gravity * dt);
    }
    // Stabilization
    if (playerEntity && stabilizationFactor > 0) {
      velocity.addScaledVector(normal, gravity * stabilizationFactor * dt);
    }

    // Movement
    if (playerEntity) {
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerEntity.quaternion);
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerEntity.quaternion);
      if (keyStates.KeyW) velocity.addScaledVector(forward, 10000 * dt);
      if (keyStates.KeyS) velocity.addScaledVector(forward, -10000 * dt);
      if (keyStates.KeyA) velocity.addScaledVector(right, -10000 * dt);
      if (keyStates.KeyD) velocity.addScaledVector(right, 10000 * dt);
      if (keyStates.Space) velocity.addScaledVector(normal.clone().negate(), 10000 * dt);
      if (keyStates.ShiftLeft) velocity.addScaledVector(normal, 10000 * dt);
    }
    const entity = playerEntity ? playerEntity : playerView;
    entity.position.addScaledVector(velocity, dt);

    // Yaw from mouse
    let yaw = prevYaw;
    if (mouseMoved && controls.isLocked) {
      const euler = new THREE.Euler().setFromQuaternion(pivotControls.quaternion, 'YXZ');
      yaw = euler.y;
    }
    const yawQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0, 'YXZ'));
    prevYaw = yaw;
    mouseMoved = false;

    // Align player entity
    if (playerEntity) {
      const up = new THREE.Vector3(0, 1, 0);
      let alignQuat = new THREE.Quaternion();
      if (Math.abs(normal.dot(up)) > 0.99) {
  const tempAxis = new THREE.Vector3(1, 0, 0);
  alignQuat.setFromUnitVectors(up, tempAxis).premultiply(
    new THREE.Quaternion().setFromUnitVectors(tempAxis, normal)
  );
} else {
  alignQuat.setFromUnitVectors(up, normal);
}

      playerEntity.quaternion.copy(alignQuat).multiply(yawQuat);
      const viewEuler = new THREE.Euler().setFromQuaternion(pivotControls.quaternion, 'YXZ');
      playerView.rotation.set(viewEuler.x, 0, 0);
    }

    renderer.render(scene, playerView);
  }

  // ---------- Start ----------
  loadAllAssets().then(() => animate(performance.now()));

  // ---------- Resize ----------
  window.addEventListener('resize', () => {
    playerView.aspect = window.innerWidth / window.innerHeight;
    playerView.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  </script>
</body>
</html>

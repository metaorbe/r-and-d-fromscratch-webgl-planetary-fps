<!DOCTYPE html>
<html>
<head>
    <title>Lunar WebGL Maquette FPS</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
        #instructions {
            position: absolute; top: 10px; left: 10px; color: white; font-family: Arial;
            background: rgba(0, 0, 0, 0.7); padding: 10px;
        }
    </style>
</head>
<body>
    <div id="instructions">Click to start FPS controls<br>ZQSD: Move, Space: Jump, Mouse: Look</div>
    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, 1920 / 1080, 0.00005, 1690); // near ????, far ????
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Center Marker ---
        const centerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32), // 1km radius
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        centerSphere.position.set(0, 0, 0);
        scene.add(centerSphere);
        console.log('Added center sphere at [0, 0, 0]');

        // --- Axes Helper ---
        const axesHelper = new THREE.AxesHelper(100); // 100km (X:red, Y:green, Z:blue)
        scene.add(axesHelper);
        console.log('Added axes helper at [0, 0, 0]');

        // --- Test Cube ---
        const cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
        const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 0, 0);
        scene.add(cube);
        console.log('Added test cube at [0, 0, 0]');

        // --- Matrix (NormMatrix, PopMatrix, LimitMatrix) ---
        const moonRadius = 1601;
        const orbitRadius = 10000;
        let normMatrix = null, popMatrix = null, limitMatrix = null;
        let popVectors = [];
        const loader = new THREE.GLTFLoader();
        loader.load('Matrix.gltf', (gltf) => {
            normMatrix = gltf.scene.getObjectByName('NormMatrix');
            popMatrix = gltf.scene.getObjectByName('PopMatrix');
            limitMatrix = gltf.scene.getObjectByName('LimitMatrix');

            if (normMatrix && popMatrix && limitMatrix) {
                // NormMatrix: Blue
                normMatrix.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0x0000ff,
                            side: THREE.DoubleSide
                        });
                        if (child.geometry && !child.geometry.attributes.normal) {
                            child.geometry.computeVertexNormals();
                            console.log('Computed normals for NormMatrix');
                        }
                        console.log('NormMatrix geometry:', child.geometry.attributes);
                        console.log('NormMatrix scale:', child.scale);
                        console.log('NormMatrix position:', child.position);
                    }
                });
                normMatrix.position.set(0, 0, 0);
                scene.add(normMatrix);

                // PopMatrix: Hidden
                popMatrix.traverse((child) => {
                    if (child.isMesh && child.geometry) {
                        const positions = child.geometry.attributes.position.array;
                        const indices = child.geometry.index ? child.geometry.index.array : null;
                        if (indices) {
                            for (let i = 0; i < indices.length; i += 3) {
                                const a = indices[i] * 3, b = indices[i + 1] * 3, c = indices[i + 2] * 3;
                                const v1 = new THREE.Vector3(positions[a], positions[a + 1], positions[a + 2]);
                                const v2 = new THREE.Vector3(positions[b], positions[b + 1], positions[b + 2]);
                                const v3 = new THREE.Vector3(positions[c], positions[c + 1], positions[c + 2]);
                                const center = new THREE.Vector3().addVectors(v1, v2).add(v3).divideScalar(3);
                                center.setLength(moonRadius + 0.1);
                                popVectors.push(center);
                            }
                        }
                        console.log('PopMatrix vectors:', popVectors.length);
                    }
                });

                // LimitMatrix: Wireframe
                limitMatrix.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            wireframe: true,
                            side: THREE.DoubleSide
                        });
                        if (child.geometry && !child.geometry.attributes.normal) {
                            child.geometry.computeVertexNormals();
                            console.log('Computed normals for LimitMatrix');
                        }
                        console.log('LimitMatrix geometry:', child.geometry.attributes);
                    }
                });
                limitMatrix.position.set(0, 0, 0);
                scene.add(limitMatrix);

                console.log('Loaded Matrix.gltf (NormMatrix, PopMatrix, LimitMatrix)');
                const boxNorm = new THREE.Box3().setFromObject(normMatrix);
                const boxLimit = new THREE.Box3().setFromObject(limitMatrix);
                console.log('NormMatrix bounding box:', boxNorm.min, boxNorm.max);
                console.log('LimitMatrix bounding box:', boxLimit.min, boxLimit.max);

                // Set initial player position
                if (popVectors.length > 1) {
                    player.position.copy(popVectors[1]);
                    player.position.setLength(moonRadius + 10);
                    console.log('Initial player position set to popVectors[1]:', player.position);
                } else {
                    console.warn('popVectors not ready, using default position');
                    player.position.set(0, moonRadius + 10, 0);
                }
                camera.lookAt(0, 0, 0);
                console.log('Camera looking at [0, 0, 0]');

                // Test raycast
                const raycaster = new THREE.Raycaster();
                raycaster.set(new THREE.Vector3(0, moonRadius + 10, 0), new THREE.Vector3(0, -1, 0));
                const testIntersects = raycaster.intersectObject(normMatrix, true);
                console.log('Test raycast on NormMatrix:', testIntersects);
            } else {
                console.error('Missing objects in Matrix.gltf');
            }
        }, undefined, (error) => {
            console.error('Error loading Matrix.gltf:', error);
        });

        // --- Player (Camera for FPS) ---
        const player = camera;
        const defaultPopPoint = new THREE.Vector3(0, moonRadius + 0.1, 0);

        // --- PointerLockControls ---
        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        document.addEventListener('click', () => controls.lock());
        document.getElementById('instructions').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => {
            document.getElementById('instructions').style.display = 'none';
            console.log('Controls locked');
        });
        controls.addEventListener('unlock', () => {
            document.getElementById('instructions').style.display = 'block';
            console.log('Controls unlocked');
        });

        // Keyboard controls (AZERTY)
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyZ': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyQ': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 0.01; canJump = false; break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyZ': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyQ': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // --- Physics ---
        const gravity = 0.0032;
        let velocity = new THREE.Vector3(0, 0, 0);
        const dt = 1 / 60;
        const moveSpeed = 0.00005;

        // --- Repop ---
        function repopPlayer(faceIndex = null) {
            if (popVectors.length === 0) {
                player.position.copy(defaultPopPoint);
                console.log('No popVectors, repopped to default', defaultPopPoint);
                return;
            }
            let targetPos;
            if (faceIndex !== null && faceIndex < popVectors.length) {
                targetPos = popVectors[faceIndex];
                console.log('Repopped to PopMatrix face', faceIndex, targetPos);
            } else {
                const randomIndex = Math.floor(Math.random() * popVectors.length);
                targetPos = popVectors[randomIndex];
                console.log('Repopped to random PopMatrix vector', randomIndex, targetPos);
            }
            player.position.copy(targetPos);
            player.position.setLength(moonRadius + 10);
            velocity.set(0, 0, 0);
            canJump = true;
            camera.lookAt(0, 0, 0);
        }

        // --- NormMatrix Collision ---
        const raycaster = new THREE.Raycaster();
        function checkNormMatrixCollision() {
            if (!normMatrix) return false;
            raycaster.set(player.position, player.position.clone().normalize().negate());
            const intersects = raycaster.intersectObject(normMatrix, true);
            console.log('NormMatrix raycast:', { position: player.position.clone(), direction: player.position.clone().normalize().negate(), intersects });
            if (intersects.length > 0 && intersects[0].distance <= moonRadius + 0.1) {
                const faceIndex = intersects[0].faceIndex;
                repopPlayer(faceIndex);
                console.log('Touched NormMatrix, repopped with faceIndex', faceIndex);
                return true;
            }
            return false;
        }

        // --- LimitMatrix Collision ---
        function checkLimitMatrixCollision() {
            if (!limitMatrix) return false;
            raycaster.set(player.position, player.position.clone().normalize());
            const intersects = raycaster.intersectObject(limitMatrix, true);
            console.log('LimitMatrix raycast:', { position: player.position.clone(), direction: player.position.clone().normalize(), intersects });
            if (intersects.length > 0 && intersects[0].distance <= orbitRadius) {
                repopPlayer();
                console.log('Touched LimitMatrix, random repop');
                return true;
            }
            return false;
        }

        // --- Tile Collision ---
        const tiles = [];
        const tileMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Simplified for debug
        for (let i = 1; i <= 10; i++) {
            const path = `tiles/LOD5_map_${String(i).padStart(5, '0')}.gltf`;
            loader.load(path, (gltf) => {
                gltf.scene.traverse((child) => {
                    if (child.isMesh) child.material = tileMaterial;
                });
                const faceIndex = i - 1;
                const tilesPerFace = 256;
                const face = Math.floor(faceIndex / tilesPerFace);
                const localIndex = faceIndex % tilesPerFace;
                const u = (localIndex % 16) / 16;
                const v = Math.floor(localIndex / 16) / 16;
                let pos;
                if (face === 0) pos = new THREE.Vector3(u - 0.5, v - 0.5, 0.5);
                else if (face === 1) pos = new THREE.Vector3(u - 0.5, 0.5, -(v - 0.5));
                else if (face === 2) pos = new THREE.Vector3(u - 0.5, -(v - 0.5), -0.5);
                else if (face === 3) pos = new THREE.Vector3(u - 0.5, -0.5, v - 0.5);
                else if (face === 4) pos = new THREE.Vector3(-0.5, v - 0.5, u - 0.5);
                else pos = new THREE.Vector3(0.5, v - 0.5, -(u - 0.5));
                pos.multiplyScalar(moonRadius);
                gltf.scene.position.copy(pos);
                scene.add(gltf.scene);
                tiles.push(gltf.scene);
                console.log(`Loaded tile ${i} at`, pos);
            }, undefined, (error) => {
                console.error(`Error loading tile ${i}:`, error);
            });
        }

        function checkTileCollision() {
            const playerPos = player.position;
            for (let tile of tiles) {
                const tilePos = tile.position;
                const dist = playerPos.distanceTo(tilePos);
                const tileSize = 156.8;
                if (dist < tileSize * 0.5) {
                    player.position.setLength(moonRadius + 0.1);
                    velocity.set(0, 0, 0);
                    canJump = true;
                    console.log('Landed on tile at', tilePos);
                    return true;
                }
            }
            return false;
        }

        // --- Gravity Based on Normals ---
        function getGravityDirection() {
            if (!normMatrix) return player.position.clone().normalize().negate();
            raycaster.set(player.position, player.position.clone().normalize().negate());
            const intersects = raycaster.intersectObject(normMatrix, true);
            console.log('Gravity raycast:', { position: player.position.clone(), direction: player.position.clone().normalize().negate(), intersects });
            if (intersects.length > 0 && intersects[0].normal) {
                return intersects[0].normal.clone().negate();
            }
            console.warn('No valid normal found for NormMatrix, using default gravity');
            return player.position.clone().normalize().negate();
        }

        // --- Lighting ---
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10000, 10000, 10000);
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        // --- Animation Loop ---
        let lastLog = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            // Check collisions
            if (checkNormMatrixCollision() || checkLimitMatrixCollision()) {
                // Repop handled
            } else if (!checkTileCollision()) {
                // Apply gravity
                const gravityDir = getGravityDirection();
                velocity.addScaledVector(gravityDir, gravity * dt);

                // Align player
                controls.getObject().up.copy(gravityDir.clone().negate());
            }

            // Move player
            const direction = new THREE.Vector3();
            controls.getDirection(direction);
            const right = new THREE.Vector3().crossVectors(direction, controls.getObject().up).normalize();
            if (moveForward) velocity.addScaledVector(direction, moveSpeed * dt);
            if (moveBackward) velocity.addScaledVector(direction, -moveSpeed * dt);
            if (moveLeft) velocity.addScaledVector(right, -moveSpeed * dt);
            if (moveRight) velocity.addScaledVector(right, moveSpeed * dt);
            player.position.addScaledVector(velocity, dt);

            // Log position
            if (time - lastLog > 1000) {
                console.log('Player position:', player.position, 'Velocity:', velocity);
                console.log('Camera:', { position: camera.position, fov: camera.fov, near: camera.near, far: camera.far });
                lastLog = time;
            }

            renderer.render(scene, camera);
        }
        animate(0);

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>